! function(t) {
	var e = {};

	function n(r) {
		if (e[r]) return e[r].exports;
		var i = e[r] = {
			i: r,
			l: !1,
			exports: {}
		};
		return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
	}
	n.m = t, n.c = e, n.d = function(t, e, r) {
		n.o(t, e) || Object.defineProperty(t, e, {
			enumerable: !0,
			get: r
		})
	}, n.r = function(t) {
		"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
			value: "Module"
		}), Object.defineProperty(t, "__esModule", {
			value: !0
		})
	}, n.t = function(t, e) {
		if (1 & e && (t = n(t)), 8 & e) return t;
		if (4 & e && "object" == typeof t && t && t.__esModule) return t;
		var r = Object.create(null);
		if (n.r(r), Object.defineProperty(r, "default", {
				enumerable: !0,
				value: t
			}), 2 & e && "string" != typeof t)
			for (var i in t) n.d(r, i, function(e) {
				return t[e]
			}.bind(null, i));
		return r
	}, n.n = function(t) {
		var e = t && t.__esModule ? function() {
			return t.default
		} : function() {
			return t
		};
		return n.d(e, "a", e), e
	}, n.o = function(t, e) {
		return Object.prototype.hasOwnProperty.call(t, e)
	}, n.p = "", n(n.s = 2)
}([function(t, e) {
	t.exports = function(t, e, n) {
		return new Proxy(n, {
			apply(n, r, i) {
				const o = function(t, e, n) {
					if (!e) return null;
					const r = new Set(document.querySelectorAll(e));
					for (; n !== t;) {
						if (r.has(n)) return n;
						n = n.parentNode
					}
					return null
				}(t, e, i[0].target);
				if (e && o || !e) return Reflect.apply(...arguments)
			}
		})
	}
}, function(t, e, n) {
	n(0);
	t.exports = function(t, e, n) {
		let r = new WeakMap;
		r.set(t, e), t.addEventListener(n, r.get(t))
	}
}, function(t, e, n) {
	"use strict";
	const r = n(0),
		i = n(3),
		o = n(1);
	class s {
		constructor() {
			this.userCallback2Handler = new Map
		}
		bind(t, e, n, s) {
			if ("object" == typeof e) return this._handleEventObj(e, (e, n) => this.bind(t, void 0, e, n)), t;
			if (!(n instanceof Array || "object" != typeof n)) return this._handleEventObj(n, (n, r) => this.bind(t, e, n, r)), t;
			if ("function" == typeof n || n instanceof Array) return this.bind(t, void 0, e, n);
			t = this._checkBindTargetInput(t);
			const c = r(t, e, s);
			return this.userCallback2Handler.set(s, c), this._isEventDIY(n) ? i[n].bind(t, s, e) : o(t, c, n), t
		}
		remove(t, e, n) {
			return t = this._checkBindTargetInput(t), "object" == typeof e && this._handleEventObj(e, (e, n) => {
				this.remove(t, e, n)
			}), this._isEventDIY(e) ? i[e].remove(t, n) : t.removeEventListener(e, this.userCallback2Handler.get(n)), t
		}
		_handleEventObj(t, e) {
			return Object.entries(t).map(t => {
				e(t[0], t[1])
			})
		}
		_checkBindTargetInput(t) {
			if ("string" == typeof t && !(t = document.querySelector(t))) throw new Error("None of DOM had been choisen, Please input a correct selector or a HTMLElement");
			return t
		}
		_isEventDIY(t) {
			return new Set(Object.keys(i)).has(t)
		}
	}
	let c = new s;
	const l = Object.create(s.prototype),
		a = c.bind.bind(c);
	Object.setPrototypeOf(a, l), Object.keys(c).map(t => {
		a[t] = c[t]
	}), window.mtEvents = a
}, function(t, e, n) {
	const r = n(4),
		i = n(5),
		o = n(6);

	function s(t, e, n) {
		const {
			lastClientX: r,
			lastClientY: i
		} = n, o = t.changedTouches[0].clientX, s = t.changedTouches[0].clientY;
		let c, l, a, u;
		switch (e.length) {
			case 1:
				a = l = u = c = e[0];
				break;
			case 2:
				a = u = e[0], l = c = e[1];
				break;
			case 3:
				a = e[0], l = c = e[1], u = e[2];
				break;
			case 4:
				a = e[0], l = e[1], u = e[2], c = e[3]
		}
		o > r ? l(t) : c(t), s > i ? u(t) : a(t), n.lastClientX = o, n.lastClientY = s
	}
	t.exports = new class {
		constructor() {
			this.tap = new r({
				eventHandlers: function(t) {
					let e = new i,
						n = new o;
					return {
						touchstart: t => {
							t.preventDefault(), n.initClientPos(t), e.timeoutCreator(300, () => {
								n.resetClientPos()
							})
						},
						touchend: r => {
							e.timer && n.isWithinDistance(r, 50, 50) && (r.preventDefault(), t(r)), e.clearTimer()
						}
					}
				}
			}), this.longtap = new r({
				eventHandlers: function(t) {
					let e = t,
						n = null,
						r = new i;
					return "object" == typeof t && (e = t[0], n = t[1]), {
						touchstart: t => {
							t.preventDefault(), r.timeoutCreator(1e3)
						},
						touchend: t => {
							r.timer ? n && n(t) : e(t), r.clearTimer()
						}
					}
				}
			}), this.dbtap = new r({
				eventHandlers: function(t) {
					let e = new i,
						n = new o;
					return {
						touchend: r => {
							e.timer ? (e.clearTimer(), n.isWithinDistance(r, 100, 100) ? (r.preventDefault(), t(r)) : console.log("Double click in different area!")) : (n.initClientPos(r), e.timeoutCreator(500, () => {
								n.resetClientPos()
							}))
						}
					}
				}
			}), this.drag = new r({
				eventHandlers: function(t) {
					let e = null;
					return {
						touchstart: t => {
							e = {
								lastClientX: t.changedTouches[0].clientX,
								lastClientY: t.changedTouches[0].clientY
							}
						},
						touchend: n => {
							if (t instanceof Array) return s(n, t, e);
							t(n)
						}
					}
				}
			}), this.swift = new r({
				eventHandlers: function(t) {
					let e = null;
					return {
						touchmove: n => {
							if (n.preventDefault(), e || (e = {
									lastClientX: n.changedTouches[0].clientX,
									lastClientY: n.changedTouches[0].clientY
								}), t instanceof Array) return s(n, t, e);
							t(n)
						}
					}
				}
			}), this.scale = new r({
				eventHandlers: function(t) {
					let e = 0,
						n = new i;
					return {
						touchmove: r => {
							r.preventDefault(), 2 === r.touches.length && (e ? n.timer || n.timeoutCreator(100, () => {
								const n = Math.sqrt(Math.pow(r.touches[0].clientX - r.touches[1].clientX, 2) + Math.pow(r.touches[0].clientY - r.touches[1].clientY, 2)),
									i = Math.floor(100 * n / e) / 100;
								r.scale = i, t(r)
							}) : e = Math.sqrt(Math.pow(r.touches[0].clientX - r.touches[1].clientX, 2) + Math.pow(r.touches[0].clientY - r.touches[1].clientY, 2)))
						},
						touchend: t => {
							e = 0
						}
					}
				}
			}), this.rotate = new r({
				eventHandlers: function(t) {
					let e = null,
						n = new i;
					return {
						touchmove: r => {
							2 === r.touches.length && (e ? n.timer || n.timeoutCreator(100, () => {
								const n = e[0].clientX,
									i = e[1].clientX,
									o = r.touches[0].clientX,
									s = r.touches[1].clientX,
									c = e[0].clientY,
									l = e[1].clientY,
									a = r.touches[0].clientY,
									u = r.touches[1].clientY,
									h = Math.sqrt(Math.pow(i - n, 2) + Math.pow(l - c, 2)),
									d = Math.sqrt(Math.pow(s - o, 2) + Math.pow(u - a, 2)),
									f = (n - o) * (l - u) - (i - s) * (c - a);
								let p = {
									rotateAngle: 90 * Math.acos((i - n)(s - o) + (l - c)(u - a) / (h * d)) / Math.PI
								};
								f < 0 ? (p.direction = "anticlockwise", p.dirt = 0) : f > 0 && (p.direction = "clockwise", p.dirt = 1), r.rotate = p, t(r)
							}) : e = r.touches)
						},
						touchend: t => {
							e = null
						}
					}
				}
			})
		}
	}
}, function(t, e, n) {
	const r = n(1),
		i = n(0);
	t.exports = class {
		constructor(t) {
			this.eventHandler = new Map, this.options = t
		}
		bind(t, e, n) {
			let o = this.options.eventHandlers(e);
			Object.keys(o).map(e => {
				o[e] = i(t, n, o[e]), r(t, o[e], e)
			}), this.eventHandler.set(e, o)
		}
		remove(t, e) {
			return Object.entries(this.eventHandler.get(e)).map(e => {
				t.removeEventListener(e[0], e[1])
			}), t
		}
	}
}, function(t, e) {
	t.exports = class {
		constructor() {
			this.timer = null
		}
		timeoutCreator(t, e) {
			this.timer = setTimeout(() => (clearTimeout(this.timer), this.timer = null, e && e()), t)
		}
		clearTimer() {
			clearTimeout(this.timer), this.timer = null
		}
	}
}, function(t, e) {
	t.exports = class {
		constructor() {
			this.lastClientX = null, this.lastClientY = null
		}
		initClientPos(t) {
			this.lastClientX = t.changedTouches[0].clientX, this.lastClientY = t.changedTouches[0].clientY
		}
		isWithinDistance(t, e, n) {
			const r = t.changedTouches[0].clientX,
				i = t.changedTouches[0].clientY,
				o = Math.abs(r - this.lastClientX),
				s = Math.abs(i - this.lastClientY);
			return o <= e && s <= n
		}
		resetClientPos() {
			this.lastClientX = null, this.lastClientY = null
		}
	}
}]);